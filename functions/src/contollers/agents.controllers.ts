import * as dialogflowcx from "@google-cloud/dialogflow-cx/";
import {PROJECT, db, Df, LOCATION} from "./constants";
import {IAgent} from "../models/agent";
import * as express from "express";

// instance to manage Dialogflow CX Agents
const client = new dialogflowcx.v3.AgentsClient(
    {keyFilename: "./flowBuilder.json"}
);

/**
 * Function controller for POST (create) requests to agents endpoint
 * @param {express.Request} req request
 * @param {express.Response} res response
 * @return {any} created agent
 */
export const create = async (
    req: express.Request, res: express.Response
): Promise<unknown> => {
  const {email} = req.body.credentials;
  const {agent: reqAgent} = req.body;

  // Static project name
  reqAgent.parent = "projects/democx-303803";

  const newAgent = new Df.Agent(reqAgent);
  newAgent.displayName = newAgent.displayName + "." + email;

  const formattedAgentLocation = client.locationPath(
      PROJECT,
      LOCATION
  );
  try {
    // Create Agent in DF CX
    const response = await client.createAgent({
      parent: formattedAgentLocation,
      agent: newAgent,
    });

    /*  Update local instance of newAgent with response agent name (id)
        name is generated by dialogflow in the format:
        projects/-/locations/-/agents/64d4cad6-4a0f-4e88-9518-538f0cb05805
        and we tokenize it to get the id which is located after /agents/
    */
    if (response[0] && typeof response[0].name === "string") {
      const formattedName = response[0].name.toString().split("/")[5];
      newAgent.name = formattedName;
    } else {
      return res.status(400).send(
          {
            error: "Error while creating the agent",
          });
    }

    // Upload agent to the database
    const agent: IAgent = {
      agentId: newAgent.name,
      displayName: newAgent.displayName,
      location: LOCATION,
      createdAt: Date.now().toString(),
      updatedAt: Date.now().toString(),
      userId: email,
    };
    await db.collection("agents").add(agent);
    return res.send(response);
  } catch (err) {
    console.error(err);
    return res.status(500).send(err);
  }
};

/**
 * Updates the requested agent in DF CX and firestore
 * @param {express.Request} req request
 * @param {express.Response} res response
 * @return {any} updated agent
 */
export const update = async (
    req: express.Request, res: express.Response
): Promise<unknown> => {
  const client = new dialogflowcx.v3.AgentsClient(
      {keyFilename: "./flowBuilder.json"}
  );

  const {email} = req.body.credentials;
  const agentId = req.params.agentId;
  const agentPath = client.agentPath(PROJECT, LOCATION, agentId);

  try {
    let [IAgent] = await client.getAgent({
      name: agentPath,
    });

    const document = await db.collection("agents")
        .where("agentId", "==", agentId).get();

    IAgent = Object.assign(IAgent, req.body);

    const update = await client.updateAgent({
      agent: IAgent,
    });

    const agent: IAgent = {
      agentId: document.docs[0].get("agentId"),
      displayName: IAgent.displayName as string,
      location: LOCATION,
      createdAt: document.docs[0].get("createdAt"),
      updatedAt: Date.now().toString(),
      userId: email,
    };

    await document.docs[0].ref.set(agent);

    return res.send(update);
  } catch (err) {
    console.error(err);
    return res.status(500).send(err);
  }
};

/**
 * Deletes the requested agent from DF CX and firestore
 * @param {express.Request} req request
 * @param {express.Response} res response
 * @return {any} deleted agent
 */
export const remove = async (
    req: express.Request, res: express.Response
): Promise<unknown> => {
  const agentId = req.params.agentId;
  const agentPath = client.agentPath(PROJECT, "global", agentId);

  try {
    const document = await db.collection("agents")
        .where("agentId", "==", agentId).get();

    // Delete document
    document.forEach(async (value) => {
      await value.ref.delete();
    });

    const response = await client.deleteAgent({name: agentPath});
    return res.send(response);
  } catch (err) {
    console.error(err);
    return res.status(400).send(err);
  }
};
